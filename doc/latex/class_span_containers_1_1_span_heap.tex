\doxysection{Span\+Containers\+::Span\+Heap\texorpdfstring{$<$}{<} T, Extent, Comparer \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{class_span_containers_1_1_span_heap}{}\label{class_span_containers_1_1_span_heap}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}


Represents a span-\/based, fixed size container with heap access.  




{\ttfamily \#include $<$Span\+Heap.\+h$>$}

Inheritance diagram for Span\+Containers\+::Span\+Heap\texorpdfstring{$<$}{<} T, Extent, Comparer \texorpdfstring{$>$}{>}\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=0.722115cm]{class_span_containers_1_1_span_heap}
\end{center}
\end{figure}
\doxysubsubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_acbf0783599d1034a54f66e1ce270e39f}\label{class_span_containers_1_1internal_1_1_span_container_acbf0783599d1034a54f66e1ce270e39f} 
using {\bfseries span\+\_\+type} = std\+::span$<$T, Extent$>$
\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a22869b80b5a5ec719f8097bd9d5faaa2}\label{class_span_containers_1_1internal_1_1_span_container_a22869b80b5a5ec719f8097bd9d5faaa2} 
using {\bfseries element\+\_\+type} = span\+\_\+type\+::element\+\_\+type
\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a34698b5872c3f13cc4840496c95396bb}\label{class_span_containers_1_1internal_1_1_span_container_a34698b5872c3f13cc4840496c95396bb} 
using {\bfseries value\+\_\+type} = span\+\_\+type\+::value\+\_\+type
\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_aeaa664707f34abfa1c5def991d6a2ca0}\label{class_span_containers_1_1internal_1_1_span_container_aeaa664707f34abfa1c5def991d6a2ca0} 
using {\bfseries pointer} = span\+\_\+type\+::pointer
\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_aae9ff6b9bfea8d03125109afd903b81e}\label{class_span_containers_1_1internal_1_1_span_container_aae9ff6b9bfea8d03125109afd903b81e} 
using {\bfseries const\+\_\+pointer} = span\+\_\+type\+::const\+\_\+pointer
\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a64abb80b5fdc009b32d3c1d603fcb8a0}\label{class_span_containers_1_1internal_1_1_span_container_a64abb80b5fdc009b32d3c1d603fcb8a0} 
using {\bfseries const\+\_\+reference} = span\+\_\+type\+::const\+\_\+reference
\item 
{\footnotesize template$<$std\+::size\+\_\+t Max\+Stack\+Size = 256$>$ }\\using \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_ac2cf8a14f79ba4ffcc945694132e4f6b}{Buffer\+Type}}
\begin{DoxyCompactList}\small\item\em Defines an appropriately sized buffer to be allocated on the heap or stack. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Buffer $>$ \newline
requires std\+::is\+\_\+lvalue\+\_\+reference\+\_\+v$<$Buffer\&$>$\&\& std\+::is\+\_\+constructible\+\_\+v$<$span\+\_\+type, Buffer\&$>$}\\constexpr \mbox{\hyperlink{class_span_containers_1_1_span_heap_a0bf6f71e93b3dc8489bbe678bad23ceb}{Span\+Heap}} (Buffer \&buffer, Comparer comparer) noexcept
\begin{DoxyCompactList}\small\item\em Constructs a new \doxylink{class_span_containers_1_1_span_heap}{Span\+Heap} using comparer and wrapping buffer. \end{DoxyCompactList}\item 
size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1_span_heap_a502cfeadaafd4528ef5b97da1bdcd1eb}{make\+\_\+threshold}} () noexcept
\begin{DoxyCompactList}\small\item\em Get the threshold at which heap\+\_\+make will be used over heap\+\_\+push. \end{DoxyCompactList}\item 
\Hypertarget{class_span_containers_1_1_span_heap_a798e703f2e7e01e215227a1b2f2baa4b}\label{class_span_containers_1_1_span_heap_a798e703f2e7e01e215227a1b2f2baa4b} 
constexpr void {\bfseries clear} () noexcept
\begin{DoxyCompactList}\small\item\em Clears all items from the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Buffer $>$ \newline
requires std\+::is\+\_\+lvalue\+\_\+reference\+\_\+v$<$Buffer\&$>$ \&\& std\+::is\+\_\+constructible\+\_\+v$<$span\+\_\+type, Buffer\&$>$}\\constexpr \mbox{\hyperlink{class_span_containers_1_1_span_heap_a7f483dfa24b80da71262eeaf59f1f8dc}{Span\+Container}} (Buffer \&buffer) noexcept
\begin{DoxyCompactList}\small\item\em Constructs a new container wrapping buffer. \end{DoxyCompactList}\item 
\Hypertarget{class_span_containers_1_1_span_heap_a7ba85597b571c4484fec9c123c08fa9a}\label{class_span_containers_1_1_span_heap_a7ba85597b571c4484fec9c123c08fa9a} 
{\bfseries Span\+Container} (span\+\_\+type \&\&)=delete
\item 
constexpr size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_a137e5e887756180fad653799515b225b}{size}} () const noexcept
\begin{DoxyCompactList}\small\item\em Gets the current size of the container. \end{DoxyCompactList}\item 
constexpr bool \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_a3919cb46d780c978a8f3e04f61291d26}{empty}} () const noexcept
\begin{DoxyCompactList}\small\item\em Gets if the container is empty or not. \end{DoxyCompactList}\item 
constexpr bool \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_a62bdcb19c7b8f204d141c3abd6ff6b76}{full}} () const noexcept
\begin{DoxyCompactList}\small\item\em Gets if the container is full or not. \end{DoxyCompactList}\item 
constexpr span\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_a6adcfa5c633a685bef25e8e8300e2e00}{data}} () const noexcept
\begin{DoxyCompactList}\small\item\em Gets the underlying span. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename U $>$ \newline
requires std\+::assignable\+\_\+from$<$T\&, U\&\&$>$}\\constexpr void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait_aa121a8ea3f57b455ca2575efd1f1594f}{push}} (U \&\&value) noexcept(std\+::is\+\_\+nothrow\+\_\+assignable$<$ T \&, U \&\& $>$\+::value \&\&!Use\+Exceptions)
\begin{DoxyCompactList}\small\item\em Assigns value to an element of the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename U $>$ \newline
requires std\+::assignable\+\_\+from$<$T\&, U\&\&$>$}\\constexpr bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait_ae5b30d64af7062a02e6c1efffe6d4e79}{try\+\_\+push}} (U \&\&value) noexcept(std\+::is\+\_\+nothrow\+\_\+assignable$<$ T \&, U \&\& $>$\+::value)
\begin{DoxyCompactList}\small\item\em Tries to assign value to an element of the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::ranges\+::range Range = std\+::initializer\+\_\+list$<$\+T$>$$>$ \newline
requires std\+::convertible\+\_\+to$<$std\+::ranges\+::range\+\_\+value\+\_\+t$<$Range$>$, T$>$}\\constexpr void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait_a45d835a02662237925490501f84bd775}{push\+\_\+range}} (Range \&\&values)
\begin{DoxyCompactList}\small\item\em Assign values to the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::ranges\+::sized\+\_\+range Range = std\+::initializer\+\_\+list$<$\+T$>$$>$ \newline
requires std\+::convertible\+\_\+to$<$std\+::ranges\+::range\+\_\+value\+\_\+t$<$Range$>$, T$>$}\\constexpr void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait_a45d835a02662237925490501f84bd775}{push\+\_\+range}} (Range \&\&values)
\begin{DoxyCompactList}\small\item\em Assign values to the container. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::ranges\+::sized\+\_\+range Range = std\+::initializer\+\_\+list$<$\+T$>$$>$ \newline
requires std\+::convertible\+\_\+to$<$std\+::ranges\+::range\+\_\+value\+\_\+t$<$Range$>$, T$>$}\\constexpr bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait_a247cc2fe0d139a2e56a3cf0d1f4212d9}{try\+\_\+push\+\_\+range}} (Range \&\&values)
\begin{DoxyCompactList}\small\item\em Tries to assign the values to the container. \end{DoxyCompactList}\item 
constexpr reference \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait_a635fbe6fc7cfd5aee71c4a58f89ed3a3}{back}} () const noexcept(!Use\+Exceptions)
\begin{DoxyCompactList}\small\item\em Gets a refrence to the item at the back of the container. \end{DoxyCompactList}\item 
constexpr pointer \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait_a1039675e077b05e71a59dd9318d44026}{try\+\_\+back}} () const noexcept
\begin{DoxyCompactList}\small\item\em Gets a pointer to the item at the back of the container. \end{DoxyCompactList}\item 
constexpr void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait_aebbe0044f1d9347ec60ec0fb89cf1ee2}{pop\+\_\+back}} () noexcept(!Use\+Exceptions)
\begin{DoxyCompactList}\small\item\em Removes an item from the back of the container. \end{DoxyCompactList}\item 
constexpr void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait_a1de34d69bef973f750d36e40716ceb32}{pop\+\_\+back}} (size\+\_\+type n) noexcept(!Use\+Exceptions)
\begin{DoxyCompactList}\small\item\em Removes n items from the back of the container. \end{DoxyCompactList}\item 
constexpr bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait_a3270221b30d28bd88683e1bb42b0d0d5}{try\+\_\+pop\+\_\+back}} () noexcept
\begin{DoxyCompactList}\small\item\em Tries to remove an item from the back of the container. \end{DoxyCompactList}\item 
constexpr bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait_afac010954c1e67a0b5c0908610e3dbc0}{try\+\_\+pop\+\_\+back}} (size\+\_\+type n) noexcept
\begin{DoxyCompactList}\small\item\em Tries to remove n items from the back of the container. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_a033f9429b061e25e7163a18f26561753}{capacity}} () noexcept
\begin{DoxyCompactList}\small\item\em Gets the capacity of the container. \end{DoxyCompactList}\item 
static constexpr size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container_aab7bfff93b28f07e958ff6e7ac32ef11}{max\+\_\+size}} ()
\begin{DoxyCompactList}\small\item\em The maximum size of the container. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_span_containers_1_1_span_heap_ae3df9039b665ae2e59eff07fad1d8e07}\label{class_span_containers_1_1_span_heap_ae3df9039b665ae2e59eff07fad1d8e07} 
static constexpr std\+::string\+\_\+view {\bfseries TYPE\+\_\+\+NAME} = "{}Span\+Heap"{}
\begin{DoxyCompactList}\small\item\em the name of this type. \end{DoxyCompactList}\item 
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a6d01f5cd05d9f4187e02ff491e90391a}\label{class_span_containers_1_1internal_1_1_span_container_a6d01f5cd05d9f4187e02ff491e90391a} 
static constexpr size\+\_\+type {\bfseries extent} = Extent
\begin{DoxyCompactList}\small\item\em The capacity of the container. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_span_containers_1_1_span_heap_ac0f1d562fc525511ff952858d35f46a7}\label{class_span_containers_1_1_span_heap_ac0f1d562fc525511ff952858d35f46a7} 
struct {\bfseries internal\+::\+Push\+Straight\+Trait$<$ Span\+Heap$<$ T, Extent, Comparer $>$, T $>$}
\item 
\Hypertarget{class_span_containers_1_1_span_heap_a80446d114d76327dc419ab75f3647117}\label{class_span_containers_1_1_span_heap_a80446d114d76327dc419ab75f3647117} 
struct {\bfseries internal\+::\+Pop\+Back\+Trait$<$ Span\+Heap$<$ T, Extent, Comparer $>$, T $>$}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$std\+::swappable T, std\+::size\+\_\+t Extent, Std\+Comparer$<$ T $>$ Comparer = std\+::less$<$\+T$>$$>$\newline
class Span\+Containers\+::\+Span\+Heap$<$ T, Extent, Comparer $>$}
Represents a span-\/based, fixed size container with heap access. 


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & The type of the item in the container. \\
\hline
{\em Extent} & The size/maximum number of elements in the container. \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Member Typedef Documentation}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_ac2cf8a14f79ba4ffcc945694132e4f6b}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!BufferType@{BufferType}}
\index{BufferType@{BufferType}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{BufferType}{BufferType}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_ac2cf8a14f79ba4ffcc945694132e4f6b} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
template$<$std\+::size\+\_\+t Max\+Stack\+Size = 256$>$ \\
using \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::\+Buffer\+Type\hspace{0.3cm}{\ttfamily [inherited]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{\ std::conditional\_t<Extent\ *\ \textcolor{keyword}{sizeof}(T)\ <=\ MaxStackSize,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::array<T,\ Extent>,\ internal::HeapArray<T,\ Extent>>}

\end{DoxyCode}


Defines an appropriately sized buffer to be allocated on the heap or stack. 

If the span would be larger than Max\+Stack\+Size, returns a stack allocated std\+::array; otherwise, returns a structure wrapping a heap allocated std\+::array. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Max\+Stack\+Size} & the maximum size, in bytes, to allocate on the stack. \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_span_containers_1_1_span_heap_a0bf6f71e93b3dc8489bbe678bad23ceb}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!SpanHeap@{SpanHeap}}
\index{SpanHeap@{SpanHeap}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{SpanHeap()}{SpanHeap()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1_span_heap_a0bf6f71e93b3dc8489bbe678bad23ceb} 
template$<$std\+::swappable T, std\+::size\+\_\+t Extent, Std\+Comparer$<$ T $>$ Comparer = std\+::less$<$\+T$>$$>$ \\
template$<$typename Buffer $>$ \newline
requires std\+::is\+\_\+lvalue\+\_\+reference\+\_\+v$<$Buffer\&$>$\&\& std\+::is\+\_\+constructible\+\_\+v$<$span\+\_\+type, Buffer\&$>$\\
\mbox{\hyperlink{class_span_containers_1_1_span_heap}{Span\+Containers\+::\+Span\+Heap}}$<$ T, Extent, Comparer $>$\+::\+Span\+Heap (\begin{DoxyParamCaption}\item[{Buffer \&}]{buffer}{, }\item[{Comparer}]{comparer}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}



Constructs a new \doxylink{class_span_containers_1_1_span_heap}{Span\+Heap} using comparer and wrapping buffer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Buffer} & the type of the underlying buffer to use. Must be an lvalue able to construct a std\+::span \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em buffer} & The underlying buffer to wrap. \\
\hline
{\em comparer} & The comparer to use when comparing elements. Defaults to std\+::less. \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{struct_span_containers_1_1internal_1_1_pop_back_trait_a635fbe6fc7cfd5aee71c4a58f89ed3a3}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!back@{back}}
\index{back@{back}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_pop_back_trait_a635fbe6fc7cfd5aee71c4a58f89ed3a3} 
template$<$typename Derived , typename T $>$ \\
reference \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait}{Span\+Containers\+::internal\+::\+Pop\+Back\+Trait}}$<$ Derived, T $>$\+::back (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets a refrence to the item at the back of the container. 

\begin{DoxyReturn}{Returns}
A refrence to the item at the back of the container. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \doxylink{class_span_containers_1_1_empty_container_error}{Empty\+Container\+Error}} & if the container is empty and Use\+Exceptions is true. \\
\hline
\end{DoxyExceptions}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a033f9429b061e25e7163a18f26561753}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!capacity@{capacity}}
\index{capacity@{capacity}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{capacity()}{capacity()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_a033f9429b061e25e7163a18f26561753} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
static constexpr size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::capacity (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets the capacity of the container. 

\begin{DoxyReturn}{Returns}
The capcity of the container. 
\end{DoxyReturn}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a6adcfa5c633a685bef25e8e8300e2e00}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!data@{data}}
\index{data@{data}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{data()}{data()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_a6adcfa5c633a685bef25e8e8300e2e00} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
span\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::data (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets the underlying span. 

\begin{DoxyReturn}{Returns}
the underlying span. 
\end{DoxyReturn}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a3919cb46d780c978a8f3e04f61291d26}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!empty@{empty}}
\index{empty@{empty}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_a3919cb46d780c978a8f3e04f61291d26} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
bool \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::empty (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets if the container is empty or not. 

\begin{DoxyReturn}{Returns}
true if the container is empty; false otherwise. 
\end{DoxyReturn}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a62bdcb19c7b8f204d141c3abd6ff6b76}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!full@{full}}
\index{full@{full}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{full()}{full()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_a62bdcb19c7b8f204d141c3abd6ff6b76} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
bool \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::full (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets if the container is full or not. 

\begin{DoxyReturn}{Returns}
true if the container is full; false otherwise. 
\end{DoxyReturn}
\Hypertarget{class_span_containers_1_1_span_heap_a502cfeadaafd4528ef5b97da1bdcd1eb}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!make\_threshold@{make\_threshold}}
\index{make\_threshold@{make\_threshold}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{make\_threshold()}{make\_threshold()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1_span_heap_a502cfeadaafd4528ef5b97da1bdcd1eb} 
template$<$std\+::swappable T, std\+::size\+\_\+t Extent, Std\+Comparer$<$ T $>$ Comparer = std\+::less$<$\+T$>$$>$ \\
size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1_span_heap}{Span\+Containers\+::\+Span\+Heap}}$<$ T, Extent, Comparer $>$\+::make\+\_\+threshold (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}, {\ttfamily [noexcept]}}



Get the threshold at which heap\+\_\+make will be used over heap\+\_\+push. 

\begin{DoxyReturn}{Returns}
the smallest number of items for which push should be used over make 
\end{DoxyReturn}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_aab7bfff93b28f07e958ff6e7ac32ef11}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!max\_size@{max\_size}}
\index{max\_size@{max\_size}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{max\_size()}{max\_size()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_aab7bfff93b28f07e958ff6e7ac32ef11} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
static constexpr size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::max\+\_\+size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}, {\ttfamily [inherited]}}



The maximum size of the container. 

This is always equal to extent. ~\newline
 \Hypertarget{struct_span_containers_1_1internal_1_1_pop_back_trait_aebbe0044f1d9347ec60ec0fb89cf1ee2}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!pop\_back@{pop\_back}}
\index{pop\_back@{pop\_back}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{pop\_back()}{pop\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_pop_back_trait_aebbe0044f1d9347ec60ec0fb89cf1ee2} 
template$<$typename Derived , typename T $>$ \\
void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait}{Span\+Containers\+::internal\+::\+Pop\+Back\+Trait}}$<$ Derived, T $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Removes an item from the back of the container. 


\begin{DoxyParams}{Parameters}
{\em The} & number of items to remove from the container. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \doxylink{class_span_containers_1_1_empty_container_error}{Empty\+Container\+Error}} & if the container is empty and Use\+Exceptions is true. \\
\hline
\end{DoxyExceptions}
\Hypertarget{struct_span_containers_1_1internal_1_1_pop_back_trait_a1de34d69bef973f750d36e40716ceb32}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!pop\_back@{pop\_back}}
\index{pop\_back@{pop\_back}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{pop\_back()}{pop\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_pop_back_trait_a1de34d69bef973f750d36e40716ceb32} 
template$<$typename Derived , typename T $>$ \\
void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait}{Span\+Containers\+::internal\+::\+Pop\+Back\+Trait}}$<$ Derived, T $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}\item[{size\+\_\+type}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Removes n items from the back of the container. 


\begin{DoxyExceptions}{Exceptions}
{\em \doxylink{class_span_containers_1_1_insufficent_items_error}{Insufficent\+Items\+Error}} & if there are less than n items in the container and Use\+Exceptions is true. \\
\hline
\end{DoxyExceptions}
\Hypertarget{struct_span_containers_1_1internal_1_1_push_straight_trait_aa121a8ea3f57b455ca2575efd1f1594f}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!push@{push}}
\index{push@{push}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{push()}{push()}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_push_straight_trait_aa121a8ea3f57b455ca2575efd1f1594f} 
template$<$typename Derived , typename T $>$ \\
template$<$typename U $>$ \newline
requires std\+::assignable\+\_\+from$<$T\&, U\&\&$>$\\
void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait}{Span\+Containers\+::internal\+::\+Push\+Straight\+Trait}}$<$ Derived, T $>$\+::push (\begin{DoxyParamCaption}\item[{U \&\&}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Assigns value to an element of the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em U} & the type of the value to assign to the container. Must be assignable to T. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em value} & The item to place in the container. \\
\hline
\end{DoxyParams}

\begin{DoxyExceptions}{Exceptions}
{\em \doxylink{class_span_containers_1_1_full_container_error}{Full\+Container\+Error}} & if the container capacity is exceeded and Use\+Exceptions is true. \\
\hline
\end{DoxyExceptions}
\Hypertarget{struct_span_containers_1_1internal_1_1_push_straight_trait_a45d835a02662237925490501f84bd775}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!push\_range@{push\_range}}
\index{push\_range@{push\_range}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{push\_range()}{push\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_push_straight_trait_a45d835a02662237925490501f84bd775} 
template$<$typename Derived , typename T $>$ \\
template$<$std\+::ranges\+::range Range = std\+::initializer\+\_\+list$<$\+T$>$$>$ \newline
requires std\+::convertible\+\_\+to$<$std\+::ranges\+::range\+\_\+value\+\_\+t$<$Range$>$, T$>$\\
void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait}{Span\+Containers\+::internal\+::\+Push\+Straight\+Trait}}$<$ Derived, T $>$\+::push\+\_\+range (\begin{DoxyParamCaption}\item[{Range \&\&}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [inherited]}}



Assign values to the container. 

This method only provides the basic exception gurantee. If range exceeds the capacty of the container, values will be pushed until capcity is reached, at which point a \doxylink{class_span_containers_1_1_full_container_error}{Full\+Container\+Error} exception is thrown. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Range} & The type of the range that contains the values. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyExceptions}{Exceptions}
{\em \doxylink{class_span_containers_1_1_full_container_error}{Full\+Container\+Error}} & If the size of the range exceeds the container capacity and Use\+Exceptions is true. \\
\hline
\end{DoxyExceptions}
\Hypertarget{struct_span_containers_1_1internal_1_1_push_straight_trait_a45d835a02662237925490501f84bd775}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!push\_range@{push\_range}}
\index{push\_range@{push\_range}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{push\_range()}{push\_range()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_push_straight_trait_a45d835a02662237925490501f84bd775} 
template$<$typename Derived , typename T $>$ \\
template$<$std\+::ranges\+::sized\+\_\+range Range = std\+::initializer\+\_\+list$<$\+T$>$$>$ \newline
requires std\+::convertible\+\_\+to$<$std\+::ranges\+::range\+\_\+value\+\_\+t$<$Range$>$, T$>$\\
void \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait}{Span\+Containers\+::internal\+::\+Push\+Straight\+Trait}}$<$ Derived, T $>$\+::push\+\_\+range (\begin{DoxyParamCaption}\item[{Range \&\&}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [inherited]}}



Assign values to the container. 

This method provides a strong exception gurantee. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Range} & The type of the range that contains the values. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+range} & If the size of the range exceeds the container capacity and Use\+Exceptions is true. \\
\hline
\end{DoxyExceptions}
\Hypertarget{class_span_containers_1_1internal_1_1_span_container_a137e5e887756180fad653799515b225b}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!size@{size}}
\index{size@{size}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1internal_1_1_span_container_a137e5e887756180fad653799515b225b} 
template$<$typename T , std\+::size\+\_\+t Extent$>$ \\
size\+\_\+type \mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::size (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets the current size of the container. 

\begin{DoxyReturn}{Returns}
The current size of the container. 
\end{DoxyReturn}
\Hypertarget{class_span_containers_1_1_span_heap_a7f483dfa24b80da71262eeaf59f1f8dc}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!SpanContainer@{SpanContainer}}
\index{SpanContainer@{SpanContainer}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{SpanContainer()}{SpanContainer()}}
{\footnotesize\ttfamily \label{class_span_containers_1_1_span_heap_a7f483dfa24b80da71262eeaf59f1f8dc} 
template$<$std\+::swappable T, std\+::size\+\_\+t Extent, Std\+Comparer$<$ T $>$ Comparer = std\+::less$<$\+T$>$$>$ \\
template$<$typename Buffer $>$ \newline
requires std\+::is\+\_\+lvalue\+\_\+reference\+\_\+v$<$Buffer\&$>$ \&\& std\+::is\+\_\+constructible\+\_\+v$<$span\+\_\+type, Buffer\&$>$\\
\mbox{\hyperlink{class_span_containers_1_1internal_1_1_span_container}{Span\+Containers\+::internal\+::\+Span\+Container}}$<$ T, Extent $>$\+::\+Span\+Container (\begin{DoxyParamCaption}\item[{Buffer \&}]{buffer}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}}



Constructs a new container wrapping buffer. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Buffer} & the type of the underlying buffer to use. Must be an lvalue able to construct a std\+::span \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em buffer} & The underlying buffer to wrap. \\
\hline
\end{DoxyParams}
\Hypertarget{struct_span_containers_1_1internal_1_1_pop_back_trait_a1039675e077b05e71a59dd9318d44026}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!try\_back@{try\_back}}
\index{try\_back@{try\_back}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{try\_back()}{try\_back()}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_pop_back_trait_a1039675e077b05e71a59dd9318d44026} 
template$<$typename Derived , typename T $>$ \\
pointer \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait}{Span\+Containers\+::internal\+::\+Pop\+Back\+Trait}}$<$ Derived, T $>$\+::try\+\_\+back (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [nodiscard]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Gets a pointer to the item at the back of the container. 

\begin{DoxyReturn}{Returns}
A pointer to the item at the back of the container or nullptr if empty. 
\end{DoxyReturn}
\Hypertarget{struct_span_containers_1_1internal_1_1_pop_back_trait_a3270221b30d28bd88683e1bb42b0d0d5}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!try\_pop\_back@{try\_pop\_back}}
\index{try\_pop\_back@{try\_pop\_back}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{try\_pop\_back()}{try\_pop\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_pop_back_trait_a3270221b30d28bd88683e1bb42b0d0d5} 
template$<$typename Derived , typename T $>$ \\
bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait}{Span\+Containers\+::internal\+::\+Pop\+Back\+Trait}}$<$ Derived, T $>$\+::try\+\_\+pop\+\_\+back (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Tries to remove an item from the back of the container. 

\begin{DoxyReturn}{Returns}
true if an item was removed; false if the container is empty. 
\end{DoxyReturn}
\Hypertarget{struct_span_containers_1_1internal_1_1_pop_back_trait_afac010954c1e67a0b5c0908610e3dbc0}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!try\_pop\_back@{try\_pop\_back}}
\index{try\_pop\_back@{try\_pop\_back}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{try\_pop\_back()}{try\_pop\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_pop_back_trait_afac010954c1e67a0b5c0908610e3dbc0} 
template$<$typename Derived , typename T $>$ \\
bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_pop_back_trait}{Span\+Containers\+::internal\+::\+Pop\+Back\+Trait}}$<$ Derived, T $>$\+::try\+\_\+pop\+\_\+back (\begin{DoxyParamCaption}\item[{size\+\_\+type}]{n}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Tries to remove n items from the back of the container. 


\begin{DoxyParams}{Parameters}
{\em The} & number of items to remove from the container. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if n items were removed; false if n is greater than size. 
\end{DoxyReturn}
\Hypertarget{struct_span_containers_1_1internal_1_1_push_straight_trait_ae5b30d64af7062a02e6c1efffe6d4e79}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!try\_push@{try\_push}}
\index{try\_push@{try\_push}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{try\_push()}{try\_push()}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_push_straight_trait_ae5b30d64af7062a02e6c1efffe6d4e79} 
template$<$typename Derived , typename T $>$ \\
template$<$typename U $>$ \newline
requires std\+::assignable\+\_\+from$<$T\&, U\&\&$>$\\
bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait}{Span\+Containers\+::internal\+::\+Push\+Straight\+Trait}}$<$ Derived, T $>$\+::try\+\_\+push (\begin{DoxyParamCaption}\item[{U \&\&}]{value}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [noexcept]}, {\ttfamily [inherited]}}



Tries to assign value to an element of the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em U} & the type of the value to assign to the container. Must be assignable to T. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em value} & The item to assign to an element of the container. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if value was assigned a value within the container; {\ttfamily false} otherwise. 
\end{DoxyReturn}
\Hypertarget{struct_span_containers_1_1internal_1_1_push_straight_trait_a247cc2fe0d139a2e56a3cf0d1f4212d9}\index{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}!try\_push\_range@{try\_push\_range}}
\index{try\_push\_range@{try\_push\_range}!SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$@{SpanContainers::SpanHeap$<$ T, Extent, Comparer $>$}}
\doxysubsubsection{\texorpdfstring{try\_push\_range()}{try\_push\_range()}}
{\footnotesize\ttfamily \label{struct_span_containers_1_1internal_1_1_push_straight_trait_a247cc2fe0d139a2e56a3cf0d1f4212d9} 
template$<$typename Derived , typename T $>$ \\
template$<$std\+::ranges\+::sized\+\_\+range Range = std\+::initializer\+\_\+list$<$\+T$>$$>$ \newline
requires std\+::convertible\+\_\+to$<$std\+::ranges\+::range\+\_\+value\+\_\+t$<$Range$>$, T$>$\\
bool \mbox{\hyperlink{struct_span_containers_1_1internal_1_1_push_straight_trait}{Span\+Containers\+::internal\+::\+Push\+Straight\+Trait}}$<$ Derived, T $>$\+::try\+\_\+push\+\_\+range (\begin{DoxyParamCaption}\item[{Range \&\&}]{values}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [constexpr]}, {\ttfamily [inherited]}}



Tries to assign the values to the container. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Range} & The type of the range that contains the values. \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if values were placed at the back of the container; {\ttfamily false} otherwise. 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/maxma/source/repos/\+Span\+Containers/lib/Span\+Heap.\+h\end{DoxyCompactItemize}
